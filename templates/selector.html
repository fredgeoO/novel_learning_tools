<!-- templates/selector.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ğŸ“š é€‰æ‹©å›¾è°±</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dark-theme.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/selector.css') }}">
</head>
<body>
    <div class="container">
        <div class="main-layout">
            <!-- å·¦ä¾§æ ‘çŠ¶ç»“æ„ -->
            <div class="tree-section">
                <h5>ğŸ“– å°è¯´ç« èŠ‚ç»“æ„</h5>
                <div class="tree-view" id="tree-container">
                    <div style="text-align: center; padding: 50px;">
                        <div class="spinner"></div>
                        <p style="margin-top: 10px; color: #cccccc;">æ­£åœ¨åŠ è½½å›¾è°±æ•°æ®...</p>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§å¡ç‰‡å±•ç¤º -->
            <div class="cards-section">
                <div class="cards-header">
                    <h3>ğŸ“‹ å¯ç”¨å›¾è°±</h3>
                </div>

                <div class="cards-container" id="cards-container">
                    <div style="text-align: center; padding: 50px; color: #cccccc;">
                        è¯·ä»å·¦ä¾§é€‰æ‹©å°è¯´æˆ–ç« èŠ‚æŸ¥çœ‹å¯ç”¨å›¾è°±
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== åº”ç”¨çŠ¶æ€ç®¡ç† ====================
        const AppState = {
            novelChapterStructure: {},
            allGraphs: {},
            selectedCacheKey: null,
            selectedTreeNode: null
        };

        // ==================== DOM å…ƒç´ ç¼“å­˜ ====================
        const DOMElements = {
            treeContainer: null,
            cardsContainer: null,
            refreshBtn: null,
            cardsTitle: null,

            init() {
                this.treeContainer = document.getElementById('tree-container');
                this.cardsContainer = document.getElementById('cards-container');
                this.refreshBtn = document.getElementById('refresh-btn');
                this.cardsTitle = document.querySelector('.cards-section h3');
            }
        };

        // ==================== API æœåŠ¡ ====================
        const ApiService = {
            async fetchNovelChapterStructure() {
                const response = await fetch('/api/novel-chapter-structure');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            },

            async fetchAllGraphs() {
                const response = await fetch('/api/graphs');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const result = await response.json();
                if (!result.success) throw new Error(result.message || 'è¯·æ±‚å¤±è´¥');
                return result.data; // âœ… å…³é”®ï¼æå– data å­—æ®µ
            },

            async fetchFilteredGraphs(novel, chapter) {
                const response = await fetch(`/api/filtered-graphs?novel=${encodeURIComponent(novel)}&chapter=${encodeURIComponent(chapter)}`);
                return await response.json();
            },

            async deleteGraph(cacheKey) {
                const response = await fetch(`/api/graph/${encodeURIComponent(cacheKey)}`, {
                    method: 'DELETE'
                });
                return await response.json();
            }
        };

        // ==================== UI æ¸²æŸ“ ====================
        const UI = {
            showLoading(container, message = 'æ­£åœ¨åŠ è½½...') {
                container.innerHTML = `
                    <div style="text-align: center; padding: 50px; width: 100%;">
                        <div class="spinner"></div>
                        <p style="margin-top: 10px; color: #cccccc;">${message}</p>
                    </div>
                `;
            },

            showError(container, message) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #dc3545;">
                        <p>âŒ ${message}</p>
                    </div>
                `;
            },

            showEmptyState(container, message = 'è¯·ä»å·¦ä¾§é€‰æ‹©å°è¯´æˆ–ç« èŠ‚æŸ¥çœ‹å¯ç”¨å›¾è°±') {
                container.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #cccccc;">
                        ${message}
                    </div>
                `;
            },

            renderTree(structure) {
                const container = DOMElements.treeContainer;
                if (!container) return;

                const novels = Object.keys(structure).sort();
                let html = '<ul class="tree-node">';

                novels.forEach(novel => {
                    const chapters = structure[novel] || [];
                    html += `
                        <li class="tree-item tree-folder" data-type="novel" data-name="${novel}">
                            <div class="tree-item-content" style="display: flex; align-items: center;">
                                <span class="tree-toggle">â–¶</span>
                                <span class="tree-label" style="margin-left: 5px;">${novel}</span>
                            </div>
                            <ul class="tree-children">
                                ${chapters.map(chapter => `
                                    <li class="tree-item" data-type="chapter" data-novel="${novel}" data-name="${chapter}">
                                        <div class="tree-item-content" style="display: flex; align-items: center; padding-left: 20px;">
                                            <span class="tree-toggle" style="opacity: 0;">â—</span>
                                            <span class="tree-label" style="margin-left: 5px;">${chapter}</span>
                                        </div>
                                    </li>
                                `).join('')}
                            </ul>
                        </li>
                    `;
                });

                html += '</ul>';
                container.innerHTML = html;
            },

            renderGraphCards(graphs, title) {
                const container = DOMElements.cardsContainer;
                if (!container) return;

                // æ›´æ–°æ ‡é¢˜
                if (DOMElements.cardsTitle && title) {
                    DOMElements.cardsTitle.textContent = `ğŸ“‹ ${title} (${Object.keys(graphs).length} ä¸ª)`;
                }

                if (Object.keys(graphs).length === 0) {
                    this.showEmptyState(container, 'æš‚æ— å¯ç”¨å›¾è°±');
                    return;
                }

                // æŒ‰åˆ›å»ºæ—¶é—´æ’åº
                const sortedKeys = Object.keys(graphs).sort((a, b) => {
                    const timeA = graphs[a].metadata?.created_at || '';
                    const timeB = graphs[b].metadata?.created_at || '';
                    return timeB.localeCompare(timeA);
                });

                const cardsHtml = sortedKeys.map(cacheKey => {
                    const graph = graphs[cacheKey];
                    const filters = graph.filters || {};
                    const metadata = graph.metadata || {};

                    return `
                        <div class="graph-card" data-cache-key="${cacheKey}">
                            <div class="card-header">
                                <h4>${filters.chapter_name || 'æœªçŸ¥'}</h4>
                                <span class="card-type">${filters.schema_name || 'æœªçŸ¥æ¨¡å¼'}</span>
                            </div>
                            <div class="card-body">
                                <div class="card-meta">
                                    <div class="meta-item">
                                        <span class="meta-label">æ¨¡å‹:</span>
                                        <span class="meta-value">${filters.model_name || 'æœªçŸ¥æ¨¡å‹'}</span>
                                    </div>
                                    <div class="meta-item">
                                        <span class="meta-label">å—å¤§å°:</span>
                                        <span class="meta-value">${filters.chunk_size || 'æœªçŸ¥'}</span>
                                    </div>
                                    <div class="meta-item">
                                        <span class="meta-label">é‡å :</span>
                                        <span class="meta-value">${filters.chunk_overlap || 'æœªçŸ¥'}</span>
                                    </div>
                                    <div class="meta-item">
                                        <span class="meta-label">ä¸Šä¸‹æ–‡:</span>
                                        <span class="meta-value">${filters.num_ctx || 'æœªçŸ¥'}</span>
                                    </div>
                                    <div class="meta-item">
                                        <span class="meta-label">åˆ›å»ºæ—¶é—´:</span>
                                        <span class="meta-value">${metadata.created_at ? new Date(metadata.created_at).toLocaleString() : 'æœªçŸ¥'}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-footer">
                                <button class="btn btn-primary btn-sm card-action-btn select-btn" data-action="select" data-cache-key="${cacheKey}">ğŸ¯ é€‰æ‹©</button>
                                <button class="btn btn-success btn-sm card-action-btn view-btn" data-action="view" data-cache-key="${cacheKey}">ğŸ‘ï¸ æŸ¥çœ‹</button>
                                <button class="btn btn-danger btn-sm card-action-btn delete-btn" data-action="delete" data-cache-key="${cacheKey}">ğŸ—‘ï¸ åˆ é™¤</button>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = `<div class="cards-grid">${cardsHtml}</div>`;
            }
        };

        // ==================== äº‹ä»¶å¤„ç†å™¨ ====================
        const EventHandlers = {
            // æ ‘èŠ‚ç‚¹å±•å¼€/æŠ˜å 
            handleTreeToggle(e) {
                const toggle = e.target.closest('.tree-toggle');
                if (!toggle || toggle.style.opacity === '0') return;

                const parentLi = toggle.closest('li');
                const childrenUl = parentLi.querySelector('.tree-children');

                if (childrenUl) {
                    const isExpanded = childrenUl.classList.contains('expanded');
                    childrenUl.classList.toggle('expanded', !isExpanded);
                    toggle.textContent = isExpanded ? 'â–¶' : 'â–¼';
                }
            },

            // æ ‘èŠ‚ç‚¹é€‰æ‹©
            handleTreeSelect(e) {
                const label = e.target.closest('.tree-label');
                if (!label) return;

                const treeItem = label.closest('.tree-item');
                if (!treeItem) return;

                // æ¸…é™¤ä¹‹å‰é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.tree-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });

                // è®¾ç½®å½“å‰é€‰ä¸­
                treeItem.classList.add('selected');
                AppState.selectedTreeNode = treeItem;

                // å¤„ç†é€‰æ‹©é€»è¾‘
                const type = treeItem.getAttribute('data-type');
                const novel = treeItem.getAttribute('data-novel');
                const name = treeItem.getAttribute('data-name');

                if (type === 'novel') {
                    this.loadNovelGraphs(name);
                } else if (type === 'chapter') {
                    this.loadChapterGraphs(novel, name);
                }
            },

            // åŠ è½½å°è¯´å›¾è°±
            async loadNovelGraphs(novel) {
                UI.showLoading(DOMElements.cardsContainer, `æ­£åœ¨åŠ è½½ ${novel} çš„å›¾è°±...`);

                try {
                    const novelGraphs = {};
                    for (const cacheKey in AppState.allGraphs) {
                        const graph = AppState.allGraphs[cacheKey];
                        const filters = graph.filters || {};
                        if (filters.novel_name === novel) {
                            novelGraphs[cacheKey] = graph;
                        }
                    }
                    UI.renderGraphCards(novelGraphs, `${novel} çš„æ‰€æœ‰å›¾è°±`);
                } catch (error) {
                    UI.showError(DOMElements.cardsContainer, `åŠ è½½å¤±è´¥: ${error.message}`);
                }
            },

            // åŠ è½½ç« èŠ‚å›¾è°±
            async loadChapterGraphs(novel, chapter) {
                UI.showLoading(DOMElements.cardsContainer, 'æ­£åœ¨åŠ è½½å›¾è°±...');

                try {
                    const data = await ApiService.fetchFilteredGraphs(novel, chapter);
                    UI.renderGraphCards(data, `${novel} - ${chapter} çš„å›¾è°±`);
                } catch (error) {
                    UI.showError(DOMElements.cardsContainer, `åŠ è½½å¤±è´¥: ${error.message}`);
                }
            },

            // å¡ç‰‡æ“ä½œå¤„ç†
            handleCardAction(e) {
                const button = e.target.closest('[data-action]');
                if (!button) return;

                const action = button.getAttribute('data-action');
                const cacheKey = button.getAttribute('data-cache-key');

                switch (action) {
                    case 'select':
                        this.selectGraph(cacheKey);
                        break;
                    case 'view':
                        this.viewGraphDetails(cacheKey);
                        break;
                    case 'delete':
                        this.deleteGraph(cacheKey, button);
                        break;
                }
            },

            // é€‰æ‹©å›¾è°±
            selectGraph(cacheKey) {
                window.location.href = `/?cache_key=${encodeURIComponent(cacheKey)}`;
            },

            // æŸ¥çœ‹å›¾è°±è¯¦æƒ…
            viewGraphDetails(cacheKey) {
                window.open(`/text?cache_key=${encodeURIComponent(cacheKey)}`, '_blank');
            },

            // åˆ é™¤å›¾è°±
            async deleteGraph(cacheKey, button) {
                if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå›¾è°±å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼")) return;

                try {
                    const result = await ApiService.deleteGraph(cacheKey);
                    if (result.success) {
                        const card = button.closest('.graph-card');
                        if (card) {
                            card.remove();
                            // æ›´æ–°æ ‡é¢˜è®¡æ•°
                            const titleElement = DOMElements.cardsTitle;
                            if (titleElement) {
                                const text = titleElement.textContent;
                                const match = text.match(/\((\d+) ä¸ª\)/);
                                if (match) {
                                    const count = parseInt(match[1]) - 1;
                                    titleElement.textContent = text.replace(/\(\d+ ä¸ª\)/, `(${count} ä¸ª)`);
                                }
                            }
                        }
                    } else {
                        alert(`åˆ é™¤å¤±è´¥ï¼š${result.error || "æœªçŸ¥é”™è¯¯"}`);
                    }
                } catch (error) {
                    console.error("åˆ é™¤è¯·æ±‚å‡ºé”™:", error);
                    alert("åˆ é™¤è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯");
                }
            },

            // åˆ·æ–°æŒ‰é’®
            handleRefresh() {
                this.loadNovelChapterStructure();
                this.loadAllGraphs();

                // é‡ç½®UIçŠ¶æ€
                UI.showEmptyState(DOMElements.cardsContainer);
                if (DOMElements.cardsTitle) {
                    DOMElements.cardsTitle.textContent = 'ğŸ“‹ å¯ç”¨å›¾è°±';
                }

                // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.tree-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });

                AppState.selectedCacheKey = null;
                AppState.selectedTreeNode = null;
            },

            // åŠ è½½å°è¯´ç« èŠ‚ç»“æ„
            async loadNovelChapterStructure() {
                try {
                    const data = await ApiService.fetchNovelChapterStructure();
                    AppState.novelChapterStructure = data;
                    UI.renderTree(data);
                } catch (error) {
                    UI.showError(DOMElements.treeContainer, `åŠ è½½å¤±è´¥: ${error.message}`);
                }
            },

            // åŠ è½½æ‰€æœ‰å›¾è°±
            async loadAllGraphs() {
                try {
                    console.log("â–¶ï¸ è¯·æ±‚ /api/graphs...");
                    const data = await ApiService.fetchAllGraphs();
                    console.log("âœ… æˆåŠŸåŠ è½½å›¾è°±æ•°é‡:", Object.keys(data).length);
                    AppState.allGraphs = data;
                } catch (error) {
                    console.error('âŒ åŠ è½½æ‰€æœ‰å›¾è°±å¤±è´¥:', error);
                    AppState.allGraphs = {};
                    // å¯é€‰ï¼šæ˜¾ç¤ºé”™è¯¯æç¤º
                    if (DOMElements.cardsContainer) {
                        UI.showError(DOMElements.cardsContainer, `å›¾è°±åŠ è½½å¤±è´¥: ${error.message}`);
                    }
                }
            }
        };

        // ==================== äº‹ä»¶ç»‘å®š ====================
        const EventBindings = {
            bindTreeEvents() {
                const container = DOMElements.treeContainer;
                if (!container) return;

                container.addEventListener('click', (e) => {
                    if (e.target.closest('.tree-toggle')) {
                        EventHandlers.handleTreeToggle(e);
                    } else if (e.target.closest('.tree-label')) {
                        EventHandlers.handleTreeSelect(e);
                    }
                });
            },

            bindCardEvents() {
                DOMElements.cardsContainer.addEventListener('click', (e) => {
                    if (e.target.closest('[data-action]')) {
                        EventHandlers.handleCardAction(e);
                    }
                });
            },

            bindRefreshEvent() {
                if (DOMElements.refreshBtn) {
                    DOMElements.refreshBtn.addEventListener('click', () => {
                        EventHandlers.handleRefresh();
                    });
                }
            },

            init() {
                this.bindTreeEvents();
                this.bindCardEvents();
                this.bindRefreshEvent();
            }
        };

        // ==================== åº”ç”¨åˆå§‹åŒ– ====================
        const App = {
            async init() {
                console.log('=== åˆå§‹åŒ–åº”ç”¨ ===');

                // åˆå§‹åŒ–DOMå…ƒç´ ç¼“å­˜
                DOMElements.init();

                // åˆå§‹åŒ–äº‹ä»¶ç»‘å®š
                EventBindings.init();

                // åŠ è½½åˆå§‹æ•°æ®
                await Promise.allSettled([
                    EventHandlers.loadNovelChapterStructure(),
                    EventHandlers.loadAllGraphs()
                ]);
            }
        };

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", () => App.init());
        } else {
            App.init();
        }
    </script>
</body>
</html>
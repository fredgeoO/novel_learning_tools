<!-- templates/selector.html -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/dark-theme.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/selector.css') }}">
<div class="selector-fragment">
    <div class="main-layout">
        <!-- å·¦ä¾§æ ‘çŠ¶ç»“æ„ -->
        <div class="tree-section">
            <h5>ğŸ“– å°è¯´ç« èŠ‚ç»“æ„</h5>
            <div class="tree-view" id="tree-container">
                <div style="text-align: center; padding: 50px;">
                    <div class="spinner"></div>
                    <p style="margin-top: 10px; color: #cccccc;">æ­£åœ¨åŠ è½½å›¾è°±æ•°æ®...</p>
                </div>
            </div>
        </div>

        <!-- å³ä¾§å¡ç‰‡å±•ç¤º -->
        <div class="cards-section">
            <div class="cards-header">
                <h3>ğŸ“‹ å¯ç”¨å›¾è°±</h3>
            </div>

            <div class="cards-container" id="cards-container">
                <div style="text-align: center; padding: 50px; color: #cccccc;">
                    è¯·ä»å·¦ä¾§é€‰æ‹©å°è¯´æˆ–ç« èŠ‚æŸ¥çœ‹å¯ç”¨å›¾è°±
                </div>
            </div>
        </div>
    </div>
</div>

<script>
(function() {
    // ==================== åº”ç”¨çŠ¶æ€ç®¡ç† ====================
    const AppState = {
        novelChapterStructure: {},
        allGraphs: {},
        selectedCacheKey: null,
        selectedTreeNode: null
    };

    // ==================== DOM å…ƒç´ ç¼“å­˜ ====================
    const DOMElements = {
        treeContainer: null,
        cardsContainer: null,
        refreshBtn: null,
        cardsTitle: null,

        init() {
            // åœ¨å½“å‰ç‰‡æ®µå†…æŸ¥æ‰¾å…ƒç´ ï¼ˆé¿å…æ±¡æŸ“å…¨å±€ï¼‰
            const root = document.querySelector('.selector-fragment');
            if (!root) return;

            this.treeContainer = root.querySelector('#tree-container');
            this.cardsContainer = root.querySelector('#cards-container');
            this.refreshBtn = root.querySelector('#refresh-btn');
            this.cardsTitle = root.querySelector('.cards-section h3');
        }
    };

    // ==================== API æœåŠ¡ ====================
    const ApiService = {
        async fetchNovelChapterStructure() {
            const response = await fetch('/api/novel-chapter-structure');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return await response.json();
        },

        async fetchAllGraphs() {
            const response = await fetch('/api/graphs');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const result = await response.json();
            if (!result.success) throw new Error(result.message || 'è¯·æ±‚å¤±è´¥');
            return result.data;
        },

        async fetchFilteredGraphs(novel, chapter) {
            const response = await fetch(`/api/filtered-graphs?novel=${encodeURIComponent(novel)}&chapter=${encodeURIComponent(chapter)}`);
            return await response.json();
        },

        async deleteGraph(cacheKey) {
            const response = await fetch(`/api/graph/${encodeURIComponent(cacheKey)}`, {
                method: 'DELETE'
            });
            return await response.json();
        }
    };

    // ==================== UI æ¸²æŸ“ ====================
    const UI = {
        showLoading(container, message = 'æ­£åœ¨åŠ è½½...') {
            if (!container) return;
            container.innerHTML = `
                <div style="text-align: center; padding: 50px; width: 100%;">
                    <div class="spinner"></div>
                    <p style="margin-top: 10px; color: #cccccc;">${message}</p>
                </div>
            `;
        },

        showError(container, message) {
            if (!container) return;
            container.innerHTML = `
                <div style="text-align: center; padding: 50px; color: #dc3545;">
                    <p>âŒ ${message}</p>
                </div>
            `;
        },

        showEmptyState(container, message = 'è¯·ä»å·¦ä¾§é€‰æ‹©å°è¯´æˆ–ç« èŠ‚æŸ¥çœ‹å¯ç”¨å›¾è°±') {
            if (!container) return;
            container.innerHTML = `
                <div style="text-align: center; padding: 50px; color: #cccccc;">
                    ${message}
                </div>
            `;
        },

        renderTree(structure) {
            const container = DOMElements.treeContainer;
            if (!container) return;

            const novels = Object.keys(structure).sort();
            let html = '<ul class="tree-node">';

            novels.forEach(novel => {
                const chapters = structure[novel] || [];
                html += `
                    <li class="tree-item tree-folder" data-type="novel" data-name="${novel}">
                        <div class="tree-item-content" style="display: flex; align-items: center;">
                            <span class="tree-toggle">â–¶</span>
                            <span class="tree-label" style="margin-left: 5px;">${novel}</span>
                        </div>
                        <ul class="tree-children">
                            ${chapters.map(chapter => `
                                <li class="tree-item" data-type="chapter" data-novel="${novel}" data-name="${chapter}">
                                    <div class="tree-item-content" style="display: flex; align-items: center; padding-left: 20px;">
                                        <span class="tree-toggle" style="opacity: 0;">â—</span>
                                        <span class="tree-label" style="margin-left: 5px;">${chapter}</span>
                                    </div>
                                </li>
                            `).join('')}
                        </ul>
                    </li>
                `;
            });

            html += '</ul>';
            container.innerHTML = html;
        },

        renderGraphCards(graphs, title) {
            const container = DOMElements.cardsContainer;
            if (!container) return;

            if (DOMElements.cardsTitle && title) {
                DOMElements.cardsTitle.textContent = `ğŸ“‹ ${title} (${Object.keys(graphs).length} ä¸ª)`;
            }

            if (Object.keys(graphs).length === 0) {
                this.showEmptyState(container, 'æš‚æ— å¯ç”¨å›¾è°±');
                return;
            }

            const sortedKeys = Object.keys(graphs).sort((a, b) => {
                const timeA = graphs[a].metadata?.created_at || '';
                const timeB = graphs[b].metadata?.created_at || '';
                return timeB.localeCompare(timeA);
            });

            const cardsHtml = sortedKeys.map(cacheKey => {
                const graph = graphs[cacheKey];
                const filters = graph.filters || {};
                const metadata = graph.metadata || {};

                return `
                    <div class="graph-card" data-cache-key="${cacheKey}">
                        <div class="card-header">
                            <h4>${filters.chapter_name || 'æœªçŸ¥'}</h4>
                            <span class="card-type">${filters.schema_name || 'æœªçŸ¥æ¨¡å¼'}</span>
                        </div>
                        <div class="card-body">
                            <div class="card-meta">
                                <div class="meta-item">
                                    <span class="meta-label">æ¨¡å‹:</span>
                                    <span class="meta-value">${filters.model_name || 'æœªçŸ¥æ¨¡å‹'}</span>
                                </div>
                                <div class="meta-item">
                                    <span class="meta-label">å—å¤§å°:</span>
                                    <span class="meta-value">${filters.chunk_size || 'æœªçŸ¥'}</span>
                                </div>
                                <div class="meta-item">
                                    <span class="meta-label">é‡å :</span>
                                    <span class="meta-value">${filters.chunk_overlap || 'æœªçŸ¥'}</span>
                                </div>
                                <div class="meta-item">
                                    <span class="meta-label">ä¸Šä¸‹æ–‡:</span>
                                    <span class="meta-value">${filters.num_ctx || 'æœªçŸ¥'}</span>
                                </div>
                                <div class="meta-item">
                                    <span class="meta-label">åˆ›å»ºæ—¶é—´:</span>
                                    <span class="meta-value">${metadata.created_at ? new Date(metadata.created_at).toLocaleString() : 'æœªçŸ¥'}</span>
                                </div>
                            </div>
                        </div>
                        <div class="card-footer">
                            <button class="btn btn-primary btn-sm card-action-btn select-btn" data-action="select" data-cache-key="${cacheKey}">ğŸ¯ é€‰æ‹©</button>
                            <button class="btn btn-success btn-sm card-action-btn view-btn" data-action="view" data-cache-key="${cacheKey}">ğŸ‘ï¸ æŸ¥çœ‹</button>
                            <button class="btn btn-danger btn-sm card-action-btn delete-btn" data-action="delete" data-cache-key="${cacheKey}">ğŸ—‘ï¸ åˆ é™¤</button>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="cards-grid">${cardsHtml}</div>`;
        }
    };

    // ==================== äº‹ä»¶å¤„ç†å™¨ ====================
    const EventHandlers = {
        handleTreeToggle(e) {
            const toggle = e.target.closest('.tree-toggle');
            if (!toggle || toggle.style.opacity === '0') return;

            const parentLi = toggle.closest('li');
            const childrenUl = parentLi.querySelector('.tree-children');

            if (childrenUl) {
                const isExpanded = childrenUl.classList.contains('expanded');
                childrenUl.classList.toggle('expanded', !isExpanded);
                toggle.textContent = isExpanded ? 'â–¶' : 'â–¼';
            }
        },

        handleTreeSelect(e) {
            const label = e.target.closest('.tree-label');
            if (!label) return;

            const treeItem = label.closest('.tree-item');
            if (!treeItem) return;

            // æ¸…é™¤ä¹‹å‰é€‰ä¸­çŠ¶æ€ï¼ˆä»…åœ¨å½“å‰ç‰‡æ®µå†…ï¼‰
            const root = document.querySelector('.selector-fragment');
            root.querySelectorAll('.tree-item.selected').forEach(item => {
                item.classList.remove('selected');
            });

            treeItem.classList.add('selected');
            AppState.selectedTreeNode = treeItem;

            const type = treeItem.getAttribute('data-type');
            const novel = treeItem.getAttribute('data-novel');
            const name = treeItem.getAttribute('data-name');

            if (type === 'novel') {
                this.loadNovelGraphs(name);
            } else if (type === 'chapter') {
                this.loadChapterGraphs(novel, name);
            }
        },

        async loadNovelGraphs(novel) {
            UI.showLoading(DOMElements.cardsContainer, `æ­£åœ¨åŠ è½½ ${novel} çš„å›¾è°±...`);
            try {
                const novelGraphs = {};
                for (const cacheKey in AppState.allGraphs) {
                    const graph = AppState.allGraphs[cacheKey];
                    const filters = graph.filters || {};
                    if (filters.novel_name === novel) {
                        novelGraphs[cacheKey] = graph;
                    }
                }
                UI.renderGraphCards(novelGraphs, `${novel} çš„æ‰€æœ‰å›¾è°±`);
            } catch (error) {
                UI.showError(DOMElements.cardsContainer, `åŠ è½½å¤±è´¥: ${error.message}`);
            }
        },

        async loadChapterGraphs(novel, chapter) {
            UI.showLoading(DOMElements.cardsContainer, 'æ­£åœ¨åŠ è½½å›¾è°±...');
            try {
                const data = await ApiService.fetchFilteredGraphs(novel, chapter);
                UI.renderGraphCards(data, `${novel} - ${chapter} çš„å›¾è°±`);
            } catch (error) {
                UI.showError(DOMElements.cardsContainer, `åŠ è½½å¤±è´¥: ${error.message}`);
            }
        },

        handleCardAction(e) {
            const button = e.target.closest('[data-action]');
            if (!button) return;

            const action = button.getAttribute('data-action');
            const cacheKey = button.getAttribute('data-cache-key');

            switch (action) {
                case 'select':
                    this.selectGraph(cacheKey);
                    break;
                case 'view':
                    this.viewGraphDetails(cacheKey);
                    break;
                case 'delete':
                    this.deleteGraph(cacheKey, button);
                    break;
            }
        },

        selectGraph(cacheKey) {
            // å°è¯•é€šçŸ¥çˆ¶é¡µé¢åˆ‡æ¢åˆ°å›¾è°±è§†å›¾å¹¶åŠ è½½ cacheKey
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'SELECT_GRAPH',
                    cacheKey: cacheKey
                }, '*'); // ç”Ÿäº§ç¯å¢ƒåº”æŒ‡å®š origin
            } else {
                // ç‹¬ç«‹é¡µé¢ fallback
                window.location.href = `/?cache_key=${encodeURIComponent(cacheKey)}`;
            }
        },

        viewGraphDetails(cacheKey) {
            window.open(`/text?cache_key=${encodeURIComponent(cacheKey)}`, '_blank');
        },

        async deleteGraph(cacheKey, button) {
            if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå›¾è°±å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼")) return;

            try {
                const result = await ApiService.deleteGraph(cacheKey);
                if (result.success) {
                    const card = button.closest('.graph-card');
                    if (card) {
                        card.remove();
                        const titleElement = DOMElements.cardsTitle;
                        if (titleElement) {
                            const text = titleElement.textContent;
                            const match = text.match(/\((\d+) ä¸ª\)/);
                            if (match) {
                                const count = parseInt(match[1]) - 1;
                                titleElement.textContent = text.replace(/\(\d+ ä¸ª\)/, `(${count} ä¸ª)`);
                            }
                        }
                    }
                } else {
                    alert(`åˆ é™¤å¤±è´¥ï¼š${result.error || "æœªçŸ¥é”™è¯¯"}`);
                }
            } catch (error) {
                console.error("åˆ é™¤è¯·æ±‚å‡ºé”™:", error);
                alert("åˆ é™¤è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯");
            }
        },

        handleRefresh() {
            this.loadNovelChapterStructure();
            this.loadAllGraphs();

            UI.showEmptyState(DOMElements.cardsContainer);
            if (DOMElements.cardsTitle) {
                DOMElements.cardsTitle.textContent = 'ğŸ“‹ å¯ç”¨å›¾è°±';
            }

            const root = document.querySelector('.selector-fragment');
            root.querySelectorAll('.tree-item.selected').forEach(item => {
                item.classList.remove('selected');
            });

            AppState.selectedCacheKey = null;
            AppState.selectedTreeNode = null;
        },

        async loadNovelChapterStructure() {
            try {
                const data = await ApiService.fetchNovelChapterStructure();
                AppState.novelChapterStructure = data;
                UI.renderTree(data);
            } catch (error) {
                UI.showError(DOMElements.treeContainer, `åŠ è½½å¤±è´¥: ${error.message}`);
            }
        },

        async loadAllGraphs() {
            try {
                const data = await ApiService.fetchAllGraphs();
                AppState.allGraphs = data;
            } catch (error) {
                console.error('âŒ åŠ è½½æ‰€æœ‰å›¾è°±å¤±è´¥:', error);
                AppState.allGraphs = {};
                if (DOMElements.cardsContainer) {
                    UI.showError(DOMElements.cardsContainer, `å›¾è°±åŠ è½½å¤±è´¥: ${error.message}`);
                }
            }
        }
    };

    // ==================== äº‹ä»¶ç»‘å®š ====================
    const EventBindings = {
        init() {
            const root = document.querySelector('.selector-fragment');
            if (!root) return;

            const treeContainer = root.querySelector('#tree-container');
            const cardsContainer = root.querySelector('#cards-container');

            if (treeContainer) {
                treeContainer.addEventListener('click', (e) => {
                    if (e.target.closest('.tree-toggle')) {
                        EventHandlers.handleTreeToggle(e);
                    } else if (e.target.closest('.tree-label')) {
                        EventHandlers.handleTreeSelect(e);
                    }
                });
            }

            if (cardsContainer) {
                cardsContainer.addEventListener('click', (e) => {
                    if (e.target.closest('[data-action]')) {
                        EventHandlers.handleCardAction(e);
                    }
                });
            }
        }
    };

    // ==================== åˆå§‹åŒ– ====================
    function initSelector() {
        DOMElements.init();
        EventBindings.init();

        // åŠ è½½æ•°æ®
        EventHandlers.loadNovelChapterStructure();
        EventHandlers.loadAllGraphs();
    }

    // ç¡®ä¿ DOM å·²åŠ è½½
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initSelector);
    } else {
        initSelector();
    }
})();
</script>
<!-- templates/viewer.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ“– å°è¯´å™äº‹åˆ†ææµè§ˆå™¨</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/viewer.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

    <div class="main-container">
        <!-- ä¾§è¾¹æ  -->
        <div class="sidebar">
            <div>
                <label>ğŸ·ï¸ é€‰æ‹©åˆ†ç±»</label>
                <select id="categorySelector">
                    <option value="å…¨éƒ¨">å…¨éƒ¨</option>
                </select>

                <label>ğŸ“š é€‰æ‹©å°è¯´</label>
                <select id="novelSelector" disabled>
                    <option value="">è¯·é€‰æ‹©åˆ†ç±»</option>
                </select>

                <label>ğŸ“„ é€‰æ‹©ç« èŠ‚</label>
                <select id="chapterSelector" disabled>
                    <option value="">è¯·é€‰æ‹©å°è¯´</option>
                </select>

                <label>ğŸ“Š é€‰æ‹©åˆ†ææŠ¥å‘Š</label>
                <select id="reportSelector" disabled>
                    <option value="">è¯·é€‰æ‹©ç« èŠ‚</option>
                </select>

                <label>
                    <input type="checkbox" id="onlyWithReports"> ğŸ” ä»…æ˜¾ç¤ºæœ‰åˆ†æçš„å†…å®¹
                </label>
            </div>

            <div class="management-section">
                <h3>âš ï¸ ç®¡ç†å·¥å…·</h3>
                <button id="deleteReportBtn" disabled>ğŸ—‘ï¸ åˆ é™¤å½“å‰æŠ¥å‘Š</button>
                <div id="deleteConfirm">
                    <p>âš ï¸ ç¡®å®šè¦åˆ é™¤å½“å‰é€‰ä¸­çš„æŠ¥å‘Šå—ï¼Ÿæ­¤æ“ä½œä¸å¯é€†ã€‚</p>
                    <button id="confirmDelete" class="btn-danger">âœ… ç¡®è®¤åˆ é™¤</button>
                    <button id="cancelDelete">âŒ å–æ¶ˆ</button>
                </div>
                <div id="deleteStatus"></div>
            </div>

            <div class="history-section">
                <h3>ğŸ•’ æµè§ˆå†å²</h3>
                <div id="historyList">
                    <p>åŠ è½½ä¸­...</p>
                </div>
            </div>
        </div>

        <!-- ä¸»å†…å®¹åŒº - æ”¹ä¸ºå·¦å³å¸ƒå±€ -->
        <div class="main-content">
            <!-- å·¦å³å¹¶æ’çš„ä¸¤ä¸ªé¢æ¿ -->
            <div class="content-split">
                <div class="panel left-panel" id="chapterContent">
                    <h2>ğŸ“– åŸæ–‡ç« èŠ‚</h2>
                    <p>è¯·åœ¨å·¦ä¾§é€‰æ‹©ä¸€æœ¬å°è¯´å’Œä¸€ä¸ªç« èŠ‚å¼€å§‹é˜…è¯»ã€‚</p>
                </div>
                <div class="panel right-panel" id="analysisContent">
                    <h2>ğŸ¤– AI åˆ†ææŠ¥å‘Š</h2>
                    <p>é€‰æ‹©ç« èŠ‚åï¼ŒAI åˆ†æç»“æœå°†åœ¨æ­¤æ˜¾ç¤ºã€‚</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€çŠ¶æ€
        const state = {
            novel: null,
            chapter: null,
            report: null
        };

        // å·¥å…·å‡½æ•°
        async function apiGet(url) {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`API é”™è¯¯: ${res.status}`);
            return await res.json();
        }

        async function apiDelete(url) {
            const res = await fetch(url, { method: 'DELETE' });
            if (!res.ok) throw new Error(`API é”™è¯¯: ${res.status}`);
            return await res.json();
        }

        function updateUrl() {
            const { novel, chapter, report } = state;
            if (novel && chapter && report) {
                const url = new URL(window.location);
                url.searchParams.set('novel', novel);
                url.searchParams.set('chapter', chapter.replace('.txt', ''));
                url.searchParams.set('report', report.replace('.txt', ''));
                window.history.replaceState({}, '', url);
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async () => {
            await loadCategories();
            await loadHistory();

            // ä» URL å‚æ•°åŠ è½½
            const urlParams = new URLSearchParams(window.location.search);
            const novelParam = urlParams.get('novel');
            const chapterParam = urlParams.get('chapter');
            const reportParam = urlParams.get('report');

            if (novelParam && chapterParam && reportParam) {
                // å»¶è¿ŸåŠ è½½ä»¥ç¡®ä¿ä¸‹æ‹‰æ¡†å·²å¡«å……
                setTimeout(async () => {
                    await loadNovels('å…¨éƒ¨');
                    const novelSel = document.getElementById('novelSelector');
                    if ([...novelSel.options].some(opt => opt.value === novelParam)) {
                        novelSel.value = novelParam;
                        await onNovelChange();
                        const chapterSel = document.getElementById('chapterSelector');
                        const fullChapter = chapterParam + '.txt';
                        if ([...chapterSel.options].some(opt => opt.value === fullChapter)) {
                            chapterSel.value = fullChapter;
                            await onChapterChange();
                            const reportSel = document.getElementById('reportSelector');
                            const fullReport = reportParam + '.txt';
                            if ([...reportSel.options].some(opt => opt.value === fullReport)) {
                                reportSel.value = fullReport;
                                await onReportChange();
                            }
                        }
                    }
                }, 800);
            }

            // ç»‘å®šäº‹ä»¶
            document.getElementById('categorySelector').addEventListener('change', onCategoryChange);
            document.getElementById('onlyWithReports').addEventListener('change', onCategoryChange);
            document.getElementById('novelSelector').addEventListener('change', onNovelChange);
            document.getElementById('chapterSelector').addEventListener('change', onChapterChange);
            document.getElementById('reportSelector').addEventListener('change', onReportChange);
            document.getElementById('deleteReportBtn').addEventListener('click', showDeleteConfirm);
            document.getElementById('cancelDelete').addEventListener('click', hideDeleteConfirm);
            document.getElementById('confirmDelete').addEventListener('click', deleteReport);
        });

        // API åŠ è½½å‡½æ•°
        async function loadCategories() {
            try {
                const data = await apiGet('/api/novels/categories');
                const sel = document.getElementById('categorySelector');
                data.categories.forEach(cat => {
                    const opt = document.createElement('option');
                    opt.value = cat;
                    opt.textContent = cat;
                    sel.appendChild(opt);
                });
            } catch (e) {
                console.error('åŠ è½½åˆ†ç±»å¤±è´¥:', e);
            }
        }

        async function loadNovels(category = 'å…¨éƒ¨', onlyWithReports = false) {
            try {
                const query = new URLSearchParams({
                    category: category,
                    only_with_reports: onlyWithReports
                });
                const data = await apiGet(`/api/novels/list?${query}`);
                const sel = document.getElementById('novelSelector');
                sel.innerHTML = '';
                data.novels.forEach(novel => {
                    const opt = document.createElement('option');
                    opt.value = novel;
                    opt.textContent = novel;
                    sel.appendChild(opt);
                });
                sel.disabled = data.novels.length === 0;
            } catch (e) {
                console.error('åŠ è½½å°è¯´å¤±è´¥:', e);
            }
        }

        async function onCategoryChange() {
            const category = document.getElementById('categorySelector').value;
            const onlyWithReports = document.getElementById('onlyWithReports').checked;
            await loadNovels(category, onlyWithReports);
        }

        async function onNovelChange() {
            const novel = document.getElementById('novelSelector').value;
            if (!novel) return;
            state.novel = novel;

            const onlyWithReports = document.getElementById('onlyWithReports').checked;
            try {
                const data = await apiGet(`/api/novels/${encodeURIComponent(novel)}/chapters?only_with_reports=${onlyWithReports}`);
                const sel = document.getElementById('chapterSelector');
                sel.innerHTML = '';
                data.chapters.forEach(chap => {
                    const opt = document.createElement('option');
                    opt.value = chap;
                    opt.textContent = chap.replace('.txt', '');
                    sel.appendChild(opt);
                });
                sel.disabled = data.chapters.length === 0;
                if (data.chapters.length > 0) {
                    sel.value = data.chapters[0];
                    state.chapter = data.chapters[0];
                    onChapterChange();
                }
            } catch (e) {
                console.error('åŠ è½½ç« èŠ‚å¤±è´¥:', e);
            }
        }

        async function onChapterChange() {
            const novel = document.getElementById('novelSelector').value;
            const chapter = document.getElementById('chapterSelector').value;
            if (!novel || !chapter) return;
            state.chapter = chapter;

            try {
                const reportsData = await apiGet(`/api/novels/${encodeURIComponent(novel)}/${encodeURIComponent(chapter)}/reports`);
                const sel = document.getElementById('reportSelector');
                sel.innerHTML = '';
                reportsData.reports.forEach(rep => {
                    const opt = document.createElement('option');
                    opt.value = rep;
                    opt.textContent = rep.replace('.txt', '');
                    sel.appendChild(opt);
                });
                sel.disabled = reportsData.reports.length === 0;
                document.getElementById('deleteReportBtn').disabled = reportsData.reports.length === 0;

                if (reportsData.reports.length > 0) {
                    sel.value = reportsData.reports[0];
                    state.report = reportsData.reports[0];
                    onReportChange();
                }

                // === ä¿®æ”¹è¿™é‡Œï¼šæ›¿æ¢æœ€åä¸¤è¡Œ ===
                const contentData = await apiGet(`/api/novels/${encodeURIComponent(novel)}/${encodeURIComponent(chapter)}/content`);

                // ä½¿ç”¨æ–°çš„æ˜¾ç¤ºå‡½æ•°ï¼ˆæ”¯æŒ Markdown å’Œç©ºè¡Œå¤„ç†ï¼‰
                displayChapterContent(contentData.chapter_content || 'æ— å†…å®¹');
                displayAnalysisContent(contentData.report_content || 'æš‚æ— åˆ†ææŠ¥å‘Š');

                updateUrl();
            } catch (e) {
                console.error('åŠ è½½å†…å®¹å¤±è´¥:', e);
            }
        }

        async function onReportChange() {
            const novel = document.getElementById('novelSelector').value;
            const chapter = document.getElementById('chapterSelector').value;
            const report = document.getElementById('reportSelector').value;
            if (!novel || !chapter || !report) return;
            state.report = report;

            try {
                const data = await apiGet(`/api/novels/${encodeURIComponent(novel)}/${encodeURIComponent(chapter)}/report/${encodeURIComponent(report)}`);

                displayAnalysisContent(data.content || 'æŠ¥å‘Šå†…å®¹ä¸ºç©º');

                updateUrl();
            } catch (e) {
                console.error('åŠ è½½æŠ¥å‘Šå¤±è´¥:', e);
            }
        }

        // åˆ é™¤é€»è¾‘
        function showDeleteConfirm() {
            document.getElementById('deleteConfirm').style.display = 'block';
            document.getElementById('deleteStatus').textContent = '';
        }

        function hideDeleteConfirm() {
            document.getElementById('deleteConfirm').style.display = 'none';
        }

        async function deleteReport() {
            const { novel, chapter, report } = state;
            if (!novel || !chapter || !report) return;

            try {
                await apiDelete(`/api/novels/${encodeURIComponent(novel)}/${encodeURIComponent(chapter)}/report/${encodeURIComponent(report)}`);
                document.getElementById('deleteStatus').innerHTML = '<span class="success">âœ… æŠ¥å‘Šå·²åˆ é™¤ã€‚</span>';
                // é‡æ–°åŠ è½½ç« èŠ‚ï¼ˆä¼šåˆ·æ–°æŠ¥å‘Šåˆ—è¡¨ï¼‰
                onChapterChange();
            } catch (e) {
                document.getElementById('deleteStatus').innerHTML = `<span class="error">âŒ åˆ é™¤å¤±è´¥: ${e.message}</span>`;
            }
            hideDeleteConfirm();
        }

        // å†å²è®°å½•
        async function loadHistory() {
            try {
                const data = await apiGet('/api/novels/history');
                const container = document.getElementById('historyList');
                if (data.history && data.history.length > 0) {
                    container.innerHTML = '';
                    data.history.forEach((item, index) => {
                        const btn = document.createElement('button');
                        btn.className = 'history-button';
                        btn.textContent = item.display;
                        btn.onclick = () => loadHistoryItem(index);
                        container.appendChild(btn);
                    });
                } else {
                    container.innerHTML = '<p>æš‚æ— æµè§ˆå†å²</p>';
                }
            } catch (e) {
                console.error('åŠ è½½å†å²å¤±è´¥:', e);
                document.getElementById('historyList').innerHTML = '<p>åŠ è½½å¤±è´¥</p>';
            }
        }

        async function loadHistoryItem(index) {
            try {
                const item = await apiGet(`/api/novels/history/${index}`);
                document.getElementById('novelSelector').value = item.novel;
                onNovelChange().then(() => {
                    const chapterSel = document.getElementById('chapterSelector');
                    if ([...chapterSel.options].some(opt => opt.value === item.chapter)) {
                        chapterSel.value = item.chapter;
                        onChapterChange();
                    }
                });
            } catch (e) {
                alert('åŠ è½½å†å²é¡¹å¤±è´¥: ' + e.message);
            }
        }
         // === æ–°å¢ï¼šæ–‡æœ¬é¢„å¤„ç†å‡½æ•° ===
        function preprocessText(text) {
            if (!text) return '';

            // 1. ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºç™½
            let processed = text.trim();

            // 2. å°†å¤šä¸ªè¿ç»­ç©ºè¡Œå‹ç¼©ä¸ºå•ä¸ªç©ºè¡Œ
            // åŒ¹é…ä¸¤ä¸ªæˆ–æ›´å¤šè¿ç»­çš„æ¢è¡Œç¬¦
            processed = processed.replace(/\n{3,}/g, '\n\n');

            return processed;
        }

        // === æ–°å¢ï¼šå®‰å…¨çš„ Markdown æ¸²æŸ“å‡½æ•° ===
        function renderMarkdown(text) {
            if (!text) return '';

            // é¢„å¤„ç†æ–‡æœ¬
            const processedText = preprocessText(text);

            // é…ç½® marked.js
            marked.setOptions({
                breaks: true, // å°†å•ä¸ªæ¢è¡Œç¬¦è½¬æ¢ä¸º <br>
                gfm: true,    // å¯ç”¨ GitHub é£æ ¼çš„ Markdown
                sanitize: false, // ä¸è¦è‡ªåŠ¨è½¬ä¹‰ HTMLï¼ˆå‡è®¾å†…å®¹å¯ä¿¡ï¼‰
                renderer: new marked.Renderer()
            });

            try {
                return marked.parse(processedText);
            } catch (e) {
                console.warn('Markdown æ¸²æŸ“å¤±è´¥ï¼Œå›é€€åˆ°çº¯æ–‡æœ¬:', e);
                // å¦‚æœ Markdown è§£æå¤±è´¥ï¼Œè¿”å›é¢„å¤„ç†åçš„çº¯æ–‡æœ¬
                return `<pre class="raw-text-content">${escapeHtml(processedText)}</pre>`;
            }
        }

        // === æ–°å¢ï¼šHTML è½¬ä¹‰å‡½æ•° ===
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // === ä¿®æ”¹ï¼šå†…å®¹æ˜¾ç¤ºå‡½æ•° ===
        function displayChapterContent(content) {
            const container = document.getElementById('chapterContent');

            // æ£€æŸ¥å†…å®¹æ˜¯å¦æ˜¯ Markdownï¼ˆåŒ…å« #, *, - ç­‰ï¼‰
            if (isMarkdownContent(content)) {
                container.innerHTML = `<div class="markdown-content">${renderMarkdown(content)}</div>`;
            } else {
                // é¢„å¤„ç†çº¯æ–‡æœ¬ï¼ˆå‹ç¼©ç©ºè¡Œï¼‰
                const processed = preprocessText(content);
                container.innerHTML = `<pre class="raw-text-content">${escapeHtml(processed)}</pre>`;
            }
        }

        function displayAnalysisContent(content) {
            const container = document.getElementById('analysisContent');

            // AI åˆ†ææŠ¥å‘Šé€šå¸¸æ˜¯ Markdownï¼Œç›´æ¥æ¸²æŸ“
            container.innerHTML = `<div class="markdown-content">${renderMarkdown(content)}</div>`;
        }
        // === æ–°å¢ï¼šæ£€æµ‹æ˜¯å¦ä¸º Markdown å†…å®¹ ===
        function isMarkdownContent(text) {
            if (!text) return false;

            // æ£€æŸ¥å¸¸è§çš„ Markdown è¯­æ³•
            const markdownPatterns = [
                /^#{1,6}\s/,           // æ ‡é¢˜
                /^\s*[\-\*\+]\s/,      // æ— åºåˆ—è¡¨
                /^\s*\d+\.\s/,         // æœ‰åºåˆ—è¡¨
                /`[^`]*`/,             // è¡Œå†…ä»£ç 
                /\*\*.*?\*\*/,         // ç²—ä½“
                /\*.*?\*/,             // æ–œä½“
                /\[.*?\]\(.*?\)/,      // é“¾æ¥
                /^>/,                  // å¼•ç”¨
                /\|.*?\|/              // è¡¨æ ¼
            ];

            return markdownPatterns.some(pattern => pattern.test(text));
        }
    </script>
</body>
</html>